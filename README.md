# Snake
EE 201L Final Project

## Introduction
Our topic for the final project for EE 201L is the classic arcade game, Snake. While a relatively simple video game to design, Snake presents a level of complexity for an underclassmen hardware class. The project gave an opportunity to tie together the various aspects of EE 201L, from finite state machines to clock division, and demonstrate our understanding of said concepts. The intention of said project is to make use of state machines and FPGA boards to implement Snake. We wanted to explicitly use concepts such as finite state machines, clock division, binary to BCD conversion, use of certain modules and blocks to represent conditions, and the VGA controller to design the arcade game.

## Design Overview
Our design focused on addressing a few aspects. We had a top design (including the VGA output), a state machine level with the three different state machines, and data path logic. As the designers, however, we spent most of our time on the state machine to get the fundamental center of the project completed. Since the state machine is the controller of the project, one we had that completed, we were able to move on to the top design. We had to connect our state machine and lower level design to the ports on the FPGA board and send out the signals so the project would run.

## Solutions
To implement everything, we first had to look at the few pieces we had to deal with. In terms of hardware, we wanted to use the following on the Nexys 3 FPGA board: the seven segment display; the up, down, left, and right buttons; and the switch Sw0. When taking a look at software, we had a number of aspects to address. Firstly, we had to look at the finite state machines. We needed a state machine for each direction the snake ends up moving (which gets triggered by the buttons) and another state machine for the food and snake segments, as eating the food changes the state. Next, we had to be able to produce both a slower system clock and an even slower clock to update the position. This we managed to accomplish through clock divisions. Another aspect we addressed was displaying the number of "food blocks" consumed, which is stored as a binary number counter. That binary number is converted into a BCD and then written onto the seven segment display by manipulating the anodes and cathodes. Next, there was a need to set a certain number of conditions for the game, such as when the game is over (lose condition), eating, or whether the snake is in a valid region or not. The last particularly important issue is the VGA controller code we implemented as well.

## Challenges
We faced numerous challenges when approaching this program. The first problem we faced was trying to figure out how to approach the problem in the first place. Snake doesn't seem like a game that can be approached with state machine design, but it involved meticulous division of tasks into "states" and transition conditions to finally come up with a way to implement the game in verilog. Another significant challenge we faced was with the VGA port. For some reason, the VGA port did not work the numerous times we attempted to display our program. However, it eventually was able to display the game after the changing of some settings (it happened almost at random). There were numerous challenges in debugging when trying to find out where certain bugs that caused the snake not move in the correct direction or cause the snake to freeze. That clearly represented a flaw in our state machine, which we proceeded to fix.

## What We Learned
From this project, we learned that there is a lot more we can do with our verilog experience. What we learned in EE 201L, from state machines to debouncing, all come in use when implementing advanced technologies in circuitry. Even common video games like Snake follow the concepts we learned in class. This gave me a stronger grasp of FPGA board and programming in verilog  as well. One of the most important aspects was the formality of the project, which mimicked almost a business proposal.
